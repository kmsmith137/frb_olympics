#
# Note: before running example0, both bonsai config files must be processed to hdf5 files with:
#    bonsai-mkweight example0_bonsai_config_n2048.txt example0_bonsai_config_n2048.hdf5
#    bonsai-mkweight example0_bonsai_config_n4096.txt example0_bonsai_config_n4096.hdf5
#

#
# In this simple example, we use three 2K-trees.  The first is upsampled by a factor 2, and the third is
# downsampled by a factor 2.
#
# A note on syntax: it would be equivalent to say 'tree_size = 2048' here, since all three tree_size values are the same.
#
# Since each tree is size 2048, it will search to a max dispersion delay equal to 2048 "tree" time samples.
# Due to the upsampling/downsampling, this will correspond to 1024, 2048, 4096 "input" time samples in the three trees.
# In this example, each input sample is 1 msec (see dt_sample) below, and the band is 400-800 MHz (see freq_* below).
# This works out to a max DM of approximately 50, 100, 200 in the three trees.
# To go to higher DM, we could either add downsampled trees, or use trees with more than 2048 channels.
#
tree_size = [ 2048, 2048, 2048 ]

# Number of frequency channels in input data.
nchan = 1024

# Upsampling factor of each tree.
# The first tree is upsampled by a factor 2 and the second/third trees are not upsampled.
nups = [ 2, 1, 1 ]

# Downsapling factor for each tree (optional).
nds = [ 1, 1, 2 ]

# Trial scattering measures.  In this simple example, we don't search over scattering.
nsm = 1         # number of trial scattering measures
sm_depth = 0    # number of tree iterations remaining when SM fanout occurs (sm_depth=4 is usually a good choice)
sm_max = 0      # largest trial SM

# Trial spectral indices.  In this simple example, we don't search over spectral index.
nbeta = 1        # number of trial spectral indices
beta_depth = 0   # number of tree iterations remaining when spectral index fanout STARTS (beta_depth=log_2(nbeta)+1 is a reasonable default)
beta_min = 0     # endpoint of searched spectral index range
beta_max = 0     # endpoint of searched spectral index range

# Input frequency band and time sampling
freq_lo_MHz = 400.0   # MHz
freq_hi_MHz = 800.0   # MHz
dt_sample = 0.001     # seconds

# Number of threads per beam.
nthreads = 1

#
# Each tree incrementally processes data in chunks.  nt_tree is the number of "tree" time samples in
# each chunk.  This is related to the number of "input" time samples by the upsampling or downsampling
# factor.
#
# Note that there is another parameter below, nt_data, which sets the chunk size for delivering input
# data to the dedisperser.  This is independent of nt_tree.
#
# Different values of nt_tree should lead to equivalent transforms (unless the detrending and RFI
# algorithms depend on it), but it will affect the latency and possibly the running time of the search.
# (256 or 512 is usually a good choice, although I haven't tested this recently)
#
nt_tree = [ 256, 256, 256 ]

#
# Number of time samples used to "pad" the incremental search.
# This should really be determined automatically, but I haven't written code to do this yet!
#
# So for now you'll need to set it by hand, using the following rules
#   - take the width of the widest peak-finding kernel (currently 4)
#   - add a few times the width of a "typical" scattering tail searched at this tree resolution (nontrivial to calculate!)
#   - round up to nearest multiple of 16 (this is the number of 32-bit floats in a cache line)
#
nt_ftree_pad = [ 16, 16, 16 ]

# DM coarse-graining factor (used when making coarse-grained triggers from fine-grained triggers)
ndm_per_trigger = 64

# Time coarse-graining factor (used when making coarse-grained triggers from fine-grained triggers)
nt_per_trigger = 64

#
# Number of time samples in each chunk of instrumental data which is fed to the dedisperser.
#
# Note that if you're running the frb_olympics, then the value of nt_data will be overridden by
# the value of 'nsamples_per_chunk' in search_params.txt.  (See code in frb_olympics/frb_bonsai.cpp)
#
# A case where the value of nt_data is meaningful is when timing the code with the 'time-tree' utility.
#
nt_data = 1024
 
#
# This optional parameter determines the point during tree dispersion where we switch from
# expanding to collapsing tree search, with a buffer in the middle.  There is code to set
# a reasonable default, so I usually just leave this unspecified in practice.
#
ftree_rank = [ 6, 6, 6 ]

Right now the frb_olympics is a little bit of a mess, since it uses code from 
several git repositories, and the python and C++ parts have been kludged together.
It definitely has more dependencies than it needs!  Another issue is that there's
an inefficiency in the pulse generation code which sometimes causes it to take a
long time to run, or use too much memory.

I think my eventual plan is to make this a pure python library, streamline it
a lot, and push the C++ parts out into other cythonized libraries (e.g. bonsai)

I'll be doing an overhaul soon, but in the meantime here are some notes.


DEPENDENCIES
------------

  - A gcc which is recent enough that C++11 is supported.
    I think that 4.4.x is OK, but I've only tested with gcc 4.8.x.

  - cython, boost, and fftw3 (and optionally mpi4py, if you want to run in
    multithreaded mode on either a multicore machine or cluster)


INSTALLATION
------------

  - Get Alex Josephy's FDMT code from github.com/ajosephy/FDMT, and copy
    cpuFDMT.py somewhere where the Python interpreter will import it (setting
    $PYTHONPATH if necessary)

  - Download and install the bonsai code from its top-secret chimefrb private repository.

  - Create a file ./Makefile.local containing compiler flags, library locations, etc.
    The format is defined in Makefile, but it will probably be easiest to copy one of
    the examples in examples/ and customize.

  - You should now be able to compile the frb_olympics with
      make
      make install

  - For now, no documentation or example runs are included here!  This will be fixed
    soon, but in the meantime you can see some examples in the 'bonsai' documentation.


FRB-COMPARE COMMAND LINE SYNTAX
-------------------------------

  The frb-compare.py command line syntax is
    ./frb-compare.py [-N] -o outstem search_params.txt algo_list.py nmc_noise nmc_pulse

  where

    search_params.txt defines various parameters of the search 
       (easiest to explain by example; see example_search_params.txt)

    algo_list.py is a python file which is imported, and registers the search
       algorithms being compared by calling frb_olympics.add_algo()

    nmc_noise, nmc_pulse are the number of "noise" and "pulse" sims being compared;
       see the FRB olympics memo for more explanation.  Note that a lot of noise sims
       are needed for convergence; I usually run with 1024.
    
    outstem determines the filenames of the summary plots
       (as ${outstem}_sigma.pdf and ${outstem}_sigmap.pdf)


  The -N flag deserves some discussion!
     By default (no -N) the pulse sims contain noise in addition to the pulse
     If -N is specified, then the pulse sims will be zero except for the pulse.

  Running with -N will generate prettier plots, but gives misleading results
  for algorithms which use the measured noise properties of the data to determine
  weighting or normalization.  (Currently only FDMT does this, but eventually we
  want to move toward all algorithms doing this, since it's a necessity for real
  data.)



INTERNALS
---------
  
Right now the internals aren't very well documented, but the following may help:

  - The docstring at the top of frb_olympics.py, which explains some key data
    structures and the interface for defining a new search algorithm.

  - For an example of a search algorithm implemented in Python, see frb_fdmt.py
    (just a wrapper around Alex Josephy's cpuFDMT.py, but shows how to implement
     the frb_olympics search algorithm API)

  - For an example of a search algorithm implemented in C++, see frb_bonsai.cpp
    (and cython boilerplate in _frb_olympics_c.pxd, frb_olympics_c.pyx)

  - For visual sanity checking, I find the program frb-dump.py useful.  It applies
    the DM transform to a timestream containing nine pulses, and plots the output
    of the transform, with arrival time on the x-axis and DM on the y-axis.  For
    an example, do
 
       ./frb-dump.py -o dump.pdf example_search_params.txt example_algo_list1.py

    then look at dump.pdf.  The nine pulses should appear along the boundary of 
    the searched (unmasked) region.  If some of the pulses don't appear then the
    searched region in (DM,arrival_time) space is too small, or something else
    is wrong.  If the pulses aren't on the boundary, then the searched region in
    (DM,arrival_time) space is too large, which may or may not be a problem.

    By default, frb-dump.py will use the first algorithm in the algo_list.py file,
    but this can be overriddent with -i [ALGO_INDEX] on the command line.
